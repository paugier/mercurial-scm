{% extends "base.html" %}

{% load extras %}
{% block content %}

<div class="row">
	<div class="col big">


<h1>Learning Mercurial in Workflows</h1>

<p>With Mercurial you can use a multitude of different workflows. This page shows some of them, including their use cases. It is intended to make it easy for Beginners of Version tracking to get going instantly and learn completely incrementally. It doesn't explain the concepts used, because there are already many other great resources doing that, for example <a title="Understanding Mercurial" href="http://www.selenic.com/mercurial/wiki/UnderstandingMercurial">the wiki</a> and <a title="Behind the Scenes" href="http://hgbook.red-bean.com/read/behind-the-scenes.html">the hgbook</a>.</p>

<p>If you want a more exhaustive tutorial with the basics, please have a look at the <a title="Mercurial Tutorial" href="http://www.selenic.com/mercurial/wiki/Tutorial">Tutorial in the Mercurial Wiki</a>. For a really detailed and very nice to read description of Mercurial, please have a look at <a title="Mercurial: The definitive Guide" href="http://hgbook.red-bean.com/">Mercurial: The definitive Guide</a>.</p>

<h2>Basic workflows</h2>

<h3>Log keeping</h3>

<h4>Use Case</h4>

The first workflow is also the easiest one: You want to use Mercurial to be able to look back when you did which changes. 

This workflow only requires an installed Mercurial and write access to some file storage (you almost definitely have that :) ). It shows the basic techniques for more complex workflows. 

<h4>Workflow</h4>

<h5>Prepare MercuriaL</h5>

As first step, you should teach Mercurial your name. For that you open the file ~/.hgrc with a text-editor and add the ui section (user interaction) with your username: 

<pre>[ui]
username = Mr. Johnson <johnson@smith.com></pre>

<h5>Initialize the project</h5>

<pre>$ hg init project</pre>

<h5>Add files and track them</h5>

<pre>$ cd project
$ (add files)
$ hg add </pre>

Note: You can also go into an existing directory with files and init the repository there.  

<pre>$ cd project
$ hg init</pre>

Alternatively you can add only specific files instead of all files in the directory. Mercurial will then track only these files and won't know about the others. The following tells mercurial to track all files whose names begin with "file0" as well as file10, file11 and file12. 

<pre>$ hg add file0* file10 file11 file12</pre>

<h5>Save changes</h5>

<pre>$ (do some changes)</pre>

see which files changed, which have been added or removed, and which aren't tracked yet. 

<pre>$ hg status</pre>

see the exact changes. 

<pre>$ hg diff</pre>

commit the changes. 

<pre>$ hg commit</pre>

now an editor pops up and asks you for a commit message. Upon saving and closing the editor, your changes have been stored by Mercurial. 

Note: You can also supply the commit message directly via <hg>hg commit -m 'MESSAGE'</hg>

<h5>Check your history</h5>

<pre>$ hg log</pre>

This prints a list of changesets along with their date, the user who committed them (you) and their commit message. 

To see a certain diff, you can use the <hg>-p</hg> switch (--patch)

<pre>$ hg log -p -r 3</pre>

<h3>Lone developer with linear history</h3>

<h4>Use case</h4> 

The second workflow is still very easy: You're a lone developer and you want to use Mercurial to keep track of your own changes. 

It works just like the sysadmin workflow, with the difference that you go back to earlied changes at times. 

To start a new project, you initialize a repository, add your files and commit whenever you finished a part of your work. 

Also you check your history from time to time, so see how you progressed. 

<h4>Workflow</h4>

<h5>Basics from log keeping</h5>

Init your project, add files, see changes and commit them. 

<pre>$ hg init project
$ cd project
$ (add files)
$ hg add # tell Mercurial to track all files
$ (do some changes)
$ hg diff # see changes
$ hg commit # save changes
$ hg log # see history</pre>

<h5>Seeing an earlier revision</h5>

Different from the sysadmin workflow, you'll want to go back in history at times and undo some changes, for example because it introduced a bug. 

To look at a previous version of your code, you can use update. Let's assume that you want to see revision 3. 

<pre>$ hg update 3</pre>

Now your code is back at revision 3, the fourth commit (Mercurial starts counting at 0). 
To check if you're really at that revision, you can use <hg>identify -n</hg>. 

<pre>$ hg identify -n</pre>

Note: <hg>identify</hg> without options gives you the short form of a unique revision ID. That ID is what Mercurial uses internally. If you tell someone about the version you updated to, you should use that ID, since the numbers can be different for other people. If you want to know the reasons behind that, please read up Mercurials [basic concepts](). When you're at the most recent revision, <hg>hg identify -n</hg> will return "-1". 

To update to the most recent revision, you can use "tip" as revision name. 

<pre>$ hg update tip</pre>

Note: If at any place any command complains, your best bet is to read what it tells you and follow that advice. 

Note: Instead of <hg>hg update</hg> you can also use the shorthand <hg>hg up</hg>. Similarly you can abbreviate <hg>hg commit</hg> to <hg>hg ci</hg>. 

Note: To get a revision devoid of files, just <hg>update</hg> to "null" via <hg>hg update null</hg>. That's the revision before any files were added. 

<h5>Fixing errors in earlier revisions</h5>

When you find a bug in some earlier revision you have two options: either you can fix it in the current code, or you can go back in history and fix the code exactly where you did it, which creates a cleaner history. 

To do it the cleaner way, you first update to the old revision, fix the bug and commit it. Afterwards you merge this revision and commit the merge. Don't worry, though: Merging in mercurial is fast and painless, as you'll see in an instant. 

Let's assume the bug was introduced in revision 3. 

<pre>$ hg update 3
$ (fix the bug)
$ hg commit</pre>

Now the fix is already stored in history. We just need to merge it with the current version of your code. 

<pre>$ hg merge</pre>

If there are conflicts use <hg>hg resolve</hg> - that's also what merge tells you to do in case of conflicts. 

First list the files with conflicts: 

<pre>$ hg resolve --list</pre>

Then resolve them one by one. <hg>resolve</hg> attempts the merge again: 

<pre>$ hg resolve conflicting_file
(fix it by hand, if necessary)</pre>

Mark the fixed file as resolved: 

<pre>$ hg resolve --mark conflicting_file</pre>

Commit the merge, as soon as you resolved all conflicts. This step is also necessary if there were no conflicts! 

<pre>$ hg commit</pre>

At this point, your fix is merged with all your other work, and you can just go on coding. Additionally the history shows clearly where you fixed the bug, so you'll always be able to check where the bug was. 

Note: Most merges will just work. You only need <hg>resolve</hg>, when <hg>merge</hg> complains. 

So now you can initialize repositories, save changes, update to previous changes and develop in a nonlinear history by committing in earlier changesets and merging the changes into the current code. 

<h3>Seperate features</h3>

<h4>Use Case</h4>

At times you'll be working on several features in parallel. If you want to avoid mixing incomplete code versions, you can create clones of your local repository and work on each feature in its own code directory. 

After finishing your feature you then <hg>pull</hg> it back into your main directory and <hg>merge</hg> the changes. 

<h4>Workflow</h4>

First create the feature clone and do some changes

<pre>$ hg clone project feature1
$ cd feature1
$ (do some changes and commits)</pre>

Now check what will come in when you <hg>pull</hg> from feature1, just like you can use <hg>diff</hg> before committing. The respective command for pulling is <hg>incoming</hg>

<pre>$ cd ../project
$ hg incoming ../feature1</pre>

Note: If you want to see the diffs, you can use <hg>hg incoming --patch</hg> just as you can do with <hg>hg log --patch</hg> for the changes in the repository. 

If you like the changes, you pull them into the project

<pre>$ hg pull ../feature1</pre>

Now you have the history of feature1 inside your project, but the changes aren't yet visible. Instead they are only stored inside a ".hg" directory of the project (<a title="Behind the Scenes" href="http://hgbook.red-bean.com/read/behind-the-scenes.html">more information on the store</a>). 

Note: From now on we'll use the name "repository" for a directory which has a .hg directory with Mercurial history. 

If you didn't do any changes in the project, while you were working on feature1, you can just update to tip (<hg>hg update tip</hg>), but it is more likely that you'll have done some other changes in between changes. In that case, it's time for merging. 

Merge feature1 into the project code: 

<pre>$ hg merge</pre>

If there are conflicts use <hg>hg resolve</hg> - that's also what merge tells you to do in case of conflicts. After you <hg>merge</hg>, you have to <hg>commit</hg> explicitely to make your <hg>merge</hg> final

<pre>$ hg commit
(enter commit message, for example "merged feature1")</pre>

You can create an arbitrary number of clones and also carry them around on USB sticks. Also you can use them to synchronize your files at home and at work, or between your desktop and your laptop. 

Note: You also have to commit after a merge when there are no conflicts, because merging creates new history and you might want to attach a specific message to the merge (like "merge feature1"). 

<h3>Sharing changes</h3>

<h4>Use Case</h4>

Now we go one step further: You are no longer alone, and you want to share your changes with others and include their changes. 

The basic requirement for that is that you have to be able to see the changes of others. 

Mercurial allows you to do that very easily by including a simple webserver from which you can <hg>pull</hg> changes just as you can pull changes from local clones. 

Note: There are a few other ways to share changes, though. Instead of using the builtin webserver, you can also send the changes by email or setup a shared repository, to where you <hg>push</hg> changes instead of pulling them. We'll cover one of those later. 

<h4>Workflow</h4>

<h5>Using the builtin webserver</h5>

This is the easiest way to quickly share changes. 

First the one who wants to share his changes creates the webserver

<pre>$ hg serve</pre>

Now all others can point their browsers to his IP address (for example 192.168.178.100) at port 8000. They will then see all his history there and can sdecide if they want to pull his changes. 

<pre>$ firefox http://192.168.178.100:8000</pre>

If they decide to include the changes, they just pull from the same URL

<pre>$ hg pull http://192.168.178.100:8000</pre>

At this point you all can work as if you had pulled from a local repository. All the data is now in your individual repositories and you can merge the changes and work with them without needing any connection to the served repository. 

<h5>Sending changes by email</h5>

Often you won't have direct access to the repository of someone else, be it because he's behind a restrictive firewall, or because you live in different timezones. You might also want to keep your changes confidential and prefer internal email (if you want additional protection, you can also encrypt the emails, for example with <a href="http://gnupg.org" title="GnuPG">GnuPG</a>). 

In that case, you can easily export your changes as patches and send them by email. 

Another reason to send them by email can be that your policy requires manual review of the changes when the other developers are used to reading diffs in emails. I'm sure you can think of more reasons. 

Sending the changes via email is pretty straightforward with Mercurial. You just <hg>export</hg> your changes and attach (or copy paste) it in your email. Your collegues can then just <hg>import</hg> them. 

First check which changes you want to export

<pre>$ cd project 
$ hg log</pre>

We assume that you want to export changeset 3 and 4: 

<pre>$ hg export 3 > change3.diff
$ hg export 4 > change4.diff</pre>

Now attach them to an email and your collegues can just run <hg>import</hg> on both diffs to get your full changes, including your user information. 

To be careful, they first <hg>clone</hg> their repository to have an integration directory as sandbox

<pre>$ hg clone project integration
$ cd integration
$ hg import change3.diff
$ hg import change4.diff</pre>

That's it. They can now test your changes in feature clones. If they accept them, they <hg>pull</hg> the changes into the main repository

<pre>$ cd ../project
$ hg pull ../integration</pre>

Note: The <em>patchbomb</em> extension automates the email-sending, but you don't need it for this workflow. 

Note 2: You can also send around bundles, which are snippets of your actual history. Just create them via 
<pre>$ hg bundle --base FIRST_REVISION_TO_BUNDLE changes.bundle</pre>
Others can then get your changes by simply pulling them, as if your bundle were an actual repository
<pre>$ hg pull path/to/changes.bundle</pre>

<h5>Using a shared repository</h5>

Sending changes by email might be the easiest way to reach people when you aren't yet part of the regular development team, but it creates additional workload: You have to <hg>bundle</hg> the changes, send mails and then <hg>import</hg> the bundles manually. Luckily there's an easier way which works quite well: The shared push repository. 

Till now we transferred all changes either via email or via <hg>pull</hg>. Now we use another otion: pushing. As the name suggests it's just the opposite of pulling: You <hg>push</hg> your changes into another repository. 

But to make use of it, we first need something we can push to. 

By default <hg>hg serve</hg> doesn't allow pushing, since that would be a major security hole. You can allow pushing in the server, but that's no solution when you live in different timezones, so we'll go with another approach here: Using a shared repository, either on an existing shared server or on a service like <a title="BitBucket" href="http://bitbucket.org">BitBucket</a>. Doing so has a bit higher starting cost and takes a bit longer to explain, but it's well worth the effort spent. 

If you want to use an existing shared server, you can use <hg>serve</hg> there and <a title="How to allow pushing for hg serve" href="http://www.selenic.com/mercurial/wiki/HgWebDirStepByStep#head-746ca383e3a62df34279ec2fca888113497da022">allow pushing</a>. Also there are some other nice ways to <a title="Multiple Committers" href="http://www.selenic.com/mercurial/wiki/MultipleCommitters">allow pushing to a Mercurial repository</a>, including simple <a title="Setting up a shared Mercurial repository using SSH" href="http://www.selenic.com/mercurial/wiki/SharedSSH">access via SSH</a>. 

Otherwise you first need to setup a BitBucket Account. Just signup at <a title="BitBucket" href="http://bitbucket.org">BitBucket</a>. After signing up (and login) hover your mouse over "Repositories". There click the item at the bottom of the opening dialog which say "Create new". 

Give it a name and a description. If you want to keep it hidden from the public, select "private". 

<pre>$ firefox http://bitbucket.org</pre>

Now your repository is created and you see instructions for <hg>push</hg>ing to it. for that you'll use a command similar to the following (just with a different URL): 

<pre>$ hg push https://bitbucket.org/ArneBab/hello/</pre>

(Replace the URL with the URL of your created repository. If your username is "Foo" and your repository is named "bar", the URL will be https://bitbucket.org/Foo/bar/)

Mercurial will ask for your BitBucket password, then <hg>push</hg> your code. 

Voilà, your code is online. 

Note: You can also <a title="use SSH for pushing to BitBucket" href="http://bitbucket.org/help/UsingSSH">use SSH for pushing to BitBucket</a>. 

Now it's time to tell all your collegues to sign up at BitBucket, too. 

After that you can click the "Admin" tab of your created repository and add the usernames of your collegues on the right side under "Permission: Writers". Now they are allowed to <hg>push</hg> code to the repository. 

(If you chose to make the repository private, you'll need to add them to "Permission: Readers", too)

If one of you now wants to publish changes, he'll simply <hg>push</hg> them to the repository, and all others get them by <hg>pull</hg>ing. 

Publish your changes: 

<pre>$ hg push https://bitbucket.org/ArneBab/hello/</pre>

Pull others changes into your local repository: 

<pre>$ hg pull https://bitbucket.org/ArneBab/hello/</pre>

People who join you in development can also just <hg>clone</hg> this repository, as if one of you were using <hg>hg serve</hg>: 

<pre>$ hg clone https://bitbucket.org/ArneBab/hello/ hello</pre>

That local repository will automatically be configured to pull/push from/to the online repository, so new contributors can just use <hg>hg push</hg> and <hg>hg pull</hg> without an URL. 

Note: To make this workflow more scaleable, each one of you can have his own BitBucket repository and you can simply <hg>pull</hg> from the others repositories. That way you can easily establish workflows in which certain people act as integrators and finally <hg>push</hg> checked code to a shared pull repository from which all others pull. 

Note: You can also use this workflow with a shared server instead of BitBucket, either via SSH or via a shared directory. An example for an SSH URL with Mercurial is be ssh://hg@bitbucket.org/ArneBab/hello (for a shared server you'd replace the "hg" in the given URL with your username). When using a shared directory you just push as if the repository in the shared directory were on your local drive. 

<h3>Summary</h3>

Now let's take a step back and look where we are. 

With the commands you already know, a bit reading of <hg>hg help &lt;command&gt;</hg> and some evil script-fu you can already do almost everything you'll ever need to do when working with source code history. So from now on almost everything is convenience, and that's a good thing. 

First this is good, because it means, that you can now use most of the concepts which are utilized in more complex workflows. 

Second it aids you, because convenience lets you focus on your task instead of focussing on your tool. It helps you concentrate on the coding itself. Still you can always go back to the basics, if you want to. 

A short summary of what you can do which can also act as a short check, if you still remember the meaning of the commands: 

<h4>create a project</h4>

<pre>$ hg init project
$ cd project
$ (add some files)
$ hg add
$ hg commit 
(enter the commit message)</pre>

<h4>do nonlinear development</h4>

<pre>$ (do some changes)
$ hg commit 
(enter the commit message)
$ hg update 0
$ (do some changes)
$ hg commit 
(enter the commit message)
$ hg merge
$ (optionally hg resolve)
$ hg commit
(enter the commit message)</pre>

<h4>use feature clones</h4>

<pre>$ cd ..
$ hg clone project feature1
$ cd feature1
$ (do some changes)
$ hg commit 
(enter the commit message)
$ cd ../project
$ hg pull ../feature1</pre>

<h4>share your repository via the integrated webserver</h4>

<pre>$ hg serve &amp;
$ cd ..
$ hg clone http://127.0.0.1:8000 project-clone</pre>

<h4>export changes to files</h4>

<pre>$ cd project-clone
$ (do some changes)
$ hg commit 
(enter the commit message)
$ hg export tip > ../changes.diff</pre>

<h4>import changes from files</h4>

<pre>$ cd ../project
$ hg import ../changes.diff</pre>

<h4>pull changes from a served repository (hg serve still runs on project)</h4>

<pre>$ cd ../feature1
$ hg pull http://127.0.0.1:8000</pre>

<h4>Use shared repositories on BitBucket</h4>

<pre>$ (setup bitbucket repo)
$ hg push https://bitbucket.org/USER/REPO
(enter name and password in the prompt)
$ hg pull https://bitbucket.org/USER/REPO</pre>


Let's move on towards useful features and a bit more advanced workflows. 

<h3>Backing out bad revisions</h3>

<h4>Use Case</h4>

When you routinely pull code from others, it can happen that you overlook some bad change. As soon as others pull that change from you, you have little chance to get completely rid of it. 

To resolve that problem, Mercurial offers you the <hg>backout</hg> command. Backing out a change means, that you tell Mercurial to create a commit which reverses the bad change. That way you don't get rid of the bad code in history, but you can remove it from new revisions. 

Note: The basic commands don't directly rewrite history. If you want to do that, you need to activate some of the extensions which are shipped with mercurial. We'll come to that later on. 

<h4>Workflow</h4>

Let's assume the bad change was revision 3, and we already have one more revision in our repository. To remove the bad code, we just <hg>backout</hg> of it. This creates a new change which reverses the bad change. After backing out, we merge that new change into the current code. 

<pre>$ hg backout 3
$ hg merge
(potentially resolve conflicts)
$ hg commit 
(enter commit message. For example: "merged backout")</pre>

That's it. You reversed the bad change. It's still recorded that it was once there (following the principle "don't rewrite history, if it's not really necessary"), but it doesn't affect future code anymore. 

<h3>Collaborative feature development</h3>

Now that we can share changes and reverse them if necessary, we go one step further: Using Mercurial to help in coordinating the coding. 

The first part is an easy way to develop features together, without requiring every developer to keep track of several feature clones. 

<h4>Use Case</h4>

When you want to split your development into several features, you need to keep track of who works on which feature and where to get which changes. 

Mercurial makes this easy for you by providing named branches. They are a part of the main repository, so they are available to everyone involved. At the same time, changes committed on a certain branch don't get mixed with the changes in the default branch, so features are kept separate, until they get merged into the default branch. 

Note: Cloning a repository always puts you onto the default branch at first. 

<h4>Workflow</h4>

When someone in your group wants to start coding on a feature without disturbing the others, he can create a named branch and commit there. When someone else wants to join in, he just updates to the branch and commits away. As soon as the feature is finished, someone merges the named branch into the default branch. 

<h5>Working in a named branch</h5>

Create the branch: 

<pre>$ hg branch feature1
(do some changes)
$ hg commit
(write commit message)</pre>

Update into the branch and work in it: 

<pre>$ hg update feature1
(do some changes)
$ hg commit
(write commit message)</pre>

Now you can <hg>commit</hg>, <hg>pull</hg>, <hg>push</hg> and <hg>merge</hg> (and anything else) as if you were working in a separate repository. If the history of the named branch is linear and you call "hg merge", Mercurial asks you to specify an explicit revision, since the branch in which you work doesn't have anything to merge. 

<h5>Merge the named branch</h5>

When you finished the feature, you <hg>merge</hg> the branch back into the default branch. 

<pre>$ hg update default
$ hg merge feature1
$ hg commit
(write commit message)</pre>

And that's it. Now you can easily keep features separate without unnecessary bookkeeping. 

Note: Named branches stay in history as permanent record after you finished your work. If you don't like having that record in your history, please have a look at some of the advanced <a title="Mercurial Workflows" href="http://www.selenic.com/mercurial/wiki/Workflows">workflows</a>. 

<h3>Marking revisions: tag and sign</h3>

<h4>Use Case</h4>

Since you can now code separate features more easily, you might want to mark certain revisions as fit for consumption (or similar). For example you might want to mark releases, or just mark off revisions as reviewed. 

For this Mercurial offers tags. Tags add a name to a revision and are part of the history. You can tag a change years after it was committed. The tag includes the information when it was added, and tags can be pulled, pushed and merged just like any other committed change. 

Note: A tag must not contain the char ":", since that char is used for specifying multiple reivions - see "hg help revisions". 

Note: To securely mark a revision, you can use the <a title="Using GnuPG to securely sign revisions in Mercurial" href="http://www.selenic.com/mercurial/wiki/GpgExtension">gpg extension</a> to sign the tag. 

<h4>Workflow</h4>

Let's assume you want to give revision 3 the name "v0.1". 

Add the tag: 

<pre>$ hg tag -r 3 v0.1</pre>

See all tags: 

<pre>$ hg tags</pre>

When you look at the log you'll now see a line in changeset 3 which marks the Tag. If someone wants to <hg>update</hg> to the tagged revision, he can just use the name of your tag: 

<pre>$ hg update v0.1</pre>

Now he'll be at the tagged revision and can work from there. 


<h3>Removing history</h3> 

<h4>Use Case</h4>

At times you will have changes in your repository, which you really don't want in it. 

There are many advanced options for removing these, and most of them use great extensions (<a title="Mercurial Queues Extension" href="http://www.selenic.com/mercurial/wiki/MqExtension">Mercurial Queues</a> is the most often used one), but in this basic guide, we'll solve the problem with just the commands we already learned. But we'll use an option to clone which we didn't yet use. 

This workflow becomes inconvenient when you need to remove changes, which are buried below many new changes. If you spot the bad changes early enough, you can get rid of them without too much effort, though. 

<h4>Workflow</h4>

Let's assume you want to get rid of revision 2 and the highest revision is 3. 

The first step is to use the "--rev" option to <hg>clone</hg>: Create a clone which only contains the changes up to the specified revision. Since you want to keep revision 1, you only clone up to that. 

$ hg clone -r 1 project stripped

Now you can <hg>export</hg> the change 3 from the original repository (project) and <hg>import</hg> it into the stripped one. 

<pre>$ cd project
$ hg export 3 > ../changes.diff
$ cd ../stripped
$ hg import ../changes.diff</pre>

If a part of the changes couldn't be applied, you'll see that part in *.rej files. If you have *.rej files, you'll have to include or discard changes by hand. 

<pre>$ cat *.rej
(apply changes by hand)
$ hg commit
(write commit message)</pre>

That's it. <hg>hg export</hg> also includes the commit message, date, committer and similar metadata, so you are already done. 

Note: removing history will change the revision IDs of revisions after the removed one, and if you pull from someone else who still has the revision you removed, you will pull the removed parts again. That's why rewriting history should most times only be done for changes which you didn't yet publicise. 

<h3>Summary</h3>

So now you can work with Mercurial in private, and also share your changes in a multitude of ways. 

Additionally you can also remove bad changes, either by creating a change in the repository which reverses the original change, or by really rewriting history, so it looks like the change never occured. 

And you can separate the work on features in a single repository by using named branches and add tags to revisions which are visible markers for others and can be used to update to the tagged revisions. 

With this we can conclude our practical guide. 

<h2>More Complex Workflows</h2>

If you now want to check some more complex workflows, please have a look at the general <a title="Mercurial Workflows" href="http://selenic.com/mercurial/wiki/Workflows">workflows wikipage</a>. 

To deepen your understanding, you should also check the <a title="Overview of the basic concepts of Mercurial" href="quick_start_concepts">basic concept overview</a>. 

Have fun with Mercurial! 



<div class="col">
                {% download_button %}
	            {% mercurial_tricks %}
		</div>
	</div>

</div>

{% endblock %}
